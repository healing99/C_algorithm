# Baekjoon 백준 - DFS와 BFS

## [2606]: 바이러스

### 🌴 문제

[문제 바로가기](https://www.acmicpc.net/problem/2606) <br>
신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.

예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.

어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.

#### ◻ 입력

첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.

#### ◻ 출력

1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

---

### 💡 구현 IDEA

- Union & Find 알고리즘 이용

### 🤠 code

```c++
#include <iostream>
using namespace std;

int unf[101];

int Find(int v) {
	if (v == unf[v]) return v;
	else return unf[v] = Find(unf[v]); // 경로압축
}

void Union(int a, int b) {
	a = Find(a);
	b = Find(b);
	if (a != b) unf[a] = b; //집합이 서로 다르므로 합치기
}

int main() {
	int n, m, a, b, res = 0;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		unf[i] = i; // 각자 다른 집합 번호로 초기화
	}
	for (int i = 1; i <= m; i++) {
		cin >> a >> b;
		Union(a, b);
	}

	for (int i = 2; i <= n; i++) { // 1번과 같은 집합인 컴퓨터의 개수 구하기
		if (Find(i) == Find(1)) res++;
	}
	cout << res << endl;
	return 0;
}
```
