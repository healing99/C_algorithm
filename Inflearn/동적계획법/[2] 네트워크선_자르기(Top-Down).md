# 인프런 알고리즘 문제풀이(C/C++)

## 동적계획법 - [2]: 네트워크 선 자르기(Top-Down)

### 🌴 문제

현수는 네트워크 선을 1m, 2m의 길이를 갖는 선으로 자르려고 합니다.
예를 들어 4m의 네트워크 선이 주어진다면<br>
1 ) 1m+1m+1m+1m<br>
2 ) 2m+1m+1m<br>
3 ) 1m+2m+1m<br>
4 ) 1m+1m+2m<br>
5 ) 2m+2m<br>
의 5가지 방법을 생각할 수 있습니다.<br>
(2)와 (3)과 (4)의 경우 왼쪽을 기준으로 자르는 위치가 다르면 다른 경우로 생각한다.<br>
그렇다면 네트워크 선의 길이가 Nm라면 몇 가지의 자르는 방법을 생각할 수 있나요?

#### ◻ 입력

첫째 줄은 네트워크 선의 총 길이인 자연수 N(3≤N≤45)이 주어집니다.<br>
입력예시: 7

#### ◻ 출력

첫 번째 줄에 부분증가수열의 최대 길이를 출력한다.<br>
출력예시: 21

---

### 💡 구현 IDEA

동적계획법 중 Top-Down : 재귀와 같은 방식으로 위에서 아래로 내려오는 방식, 함수 호출을 줄이기 위해 **메모이제이션**을 사용

- `dy`라는 일차원 배열 만들고, 각 인덱스(1, 2, ..., 7) 마다 각각 자르는 방식의 수를 저장
- 메모이제이션을 활용해서 이미 입력된 값을 호출하는 경우에는 `dy`에 저장된 값을 리턴해주면 됨<br>
  (이미 입력되었다는 것은 `dy[n] > 0` 이라는 의미)

### 🤠 code

```c++
#include <iostream>
using namespace std;

int dy[101];

int DFS(int n) {
	if (dy[n] > 0) return dy[n]; //값이 존재하면 저장된 값 리턴
	if (n == 1 || n == 2) return n;
	else return dy[n] = DFS(n - 1) + DFS(n - 2); //배열에 저장해주고, 그 값을 리턴
}

int main() {
	int n;
	cin >> n;
	cout << DFS(n);
	return 0;
}
```
