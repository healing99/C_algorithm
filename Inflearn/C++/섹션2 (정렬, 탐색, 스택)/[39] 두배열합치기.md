# 인프런 알고리즘 문제풀이(C/C++)

## [39]: 두 배열 합치기

### 🌴 문제

오름차순으로 정렬이 된 두 배열이 주어지면 두 배열을 오름차순으로 합쳐 출력하는 프로그램을 작성하세요.

#### ◻ 입력

첫 번째 줄에 첫 번째 배열의 크기 N(1<=N<=100)이 주어집니다.<br>
두 번째 줄에 N개의 배열 원소가 오름차순으로 주어집니다.<br>
세 번째 줄에 두 번째 배열의 크기 M(1<=M<=100)이 주어집니다.<br>
네 번째 줄에 M개의 배열 원소가 오름차순으로 주어집니다.<br>
각 배열의 원소는 int형 변수의 크기를 넘지 않습니다.<br>
입력예시 :<br>
3<br>
1 3 5<br>
5<br>
2 3 6 7 9

#### ◻ 출력

오름차순으로 정렬된 배열을 출력합니다.<br>
출력예시 : <br>
1 2 3 3 5 6 7 9

---

### 💡 구현 IDEA

(투포인터 알고리즘)<br>
p1: 첫번째 배열의 인덱스를 차례대로 가리키는 포인터 변수<br>
p2: 두번째 배열의 인덱스를 차례대로 가리키는 포인터 변수<br>
p3: 결론적으로 두 배열을 합칠 새로운 배열의 인덱스를 가리키는 포인터 변수

### 🤠 MY code

```c++
#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;
int a[101], b[101], c[300];
int main(){
	int n, m, i, p1=1, p2=1, p3=1;
	scanf("%d", &n);
	for(i=1; i<=n; i++){
		scanf("%d", &a[i]);
	}
	scanf("%d", &m);
	for(i=1; i<=m; i++){
		scanf("%d", &b[i]);
	}
	while(p1<=n && p2<=m){
		if(a[p1]<b[p2]){
			c[p3++]=a[p1++];
		}
		else{
			c[p3++]=b[p2++];
		}
	}
	//한 쪽 배열이 남은 경우
	while(p1<=n) c[p3++]=a[p1++];
	while(p2<=m) c[p3++]=b[p2++];
	//p3는 현재 마지막 자료의 한 칸 뒤를 가리키고 있는 채 끝남
	for(i=1; i<p3; i++){
		printf("%d ", c[i]);
	}
	return 0;
}
```
