# 인프런 알고리즘 문제풀이(C/C++)

## [81]: 벨만-포드 알고리즘

### 🌴 문제

N개의 도시가 주어지고, 각 도시들을 연결하는 도로와 해당 도로를 통행하는 비용이 주어질 때 한 도시에서 다른 도시로 이동하는데 쓰이는 비용의 최소값을 구하는 프로그램을 작성하세요.

<img src="https://user-images.githubusercontent.com/49135797/135294205-611ba370-e88c-42e1-bd54-dbe6c0c04b34.png">

#### ◻ 입력

첫 번째 줄에는 도시의 수N(N<=100)과 도로수 M(M<=200)가 주어지고, M줄에 걸쳐 도로정보와 비용이 주어진다.<br>
만약 1번 도시와 2번도시가 연결되고 그 비용이 13이면 “1 2 13”으로 주어진다. 그 다음 마지막 줄에 출발도시와 도착도시가 주어진다.<br>
입력예시 : <br>
5 7<br>
1 2 5<br>
1 3 4<br>
2 3 -3<br>
2 5 13<br>
3 4 5<br>
4 2 3<br>
4 5 7<br>
1 5

#### ◻ 출력

출발도시에서 도착도시까지 가는데 걸리는 최소비용을 출력한다. 음의 사이클이 존재할 경우 -1를 출력한다.<br>
출력예시 :<br>
14

---

### 💡 구현 IDEA

그래프는 굳이 인접리스트로 구현할 필요 없음 <br>

정점이 n개있을때, 간선을 1개, 2개 ... (n-1)개 이용하는 방법이 있음 <br>
-> 정점 n개를 사용하는 (최소 경로인)경우는 존재할 수 없음 (음의 사이클이 생성될 것)

**과정 설명**

- 1개의 간선으로 각 노드에 도달하는 방법 0, 5, 4, inf, inf 입력

- 2개의 간선으로 각 노드에 도달하는 방법 (위의 '1개 간선이용한 경우'에 더하여 구할 것)

  - 2번 노드 :
    - (1 -> 1) + (1 -> 2) = 0 + 5 = 5 : 갱신 x
    - (1 -> 4) + (4 -> 2) = inf + 5 : 갱신 x
  - 3번 노드 :
    - (1 -> 1) + (1 -> 3) = 0 + 4 = 4 : 갱신 x
    - (1 -> 2) + (2 -> 3) = 5 + (-3) = 2 : 갱신
  - 4번 노드 :
    - (1 -> 3) + (3 -> 4) = 4 + 5 = 9 : 갱신
  - 5번 노드 :
    - (1 -> 2) + (2 -> 5) = 5 + 13 = 18 : 갱신
    - (1 -> 4) + (4 -> 5) = inf + 7 : 갱신 x

- 3개의 간선으로 각 노드에 도달하는 방법 (위의 '2개 간선이용한 경우'에 더하여 구할 것)

  - 2번 노드 :
    - (1 -> 1) + (1 -> 2) = 0 + 5 = 5 : 갱신 x
    - (1 -> 4) + (4 -> 2) = 9 + 3 = 12 : 갱신 x
  - 3번 노드 :
    - (1 -> 1) + (1 -> 3) = 0 + 4 : 갱신 x
    - (1 -> 2) + (2 -> 3) = 5 + (-3) = 2 : 갱신 x
  - 4번 노드 :
    - (1 -> 3) + (3 -> 4) = 2 + 5 = 7 : 갱신
  - 5번 노드 :
    - (1 -> 2) + (2 -> 5) = 5 + 13 = 18 : 갱신 x
    - (1 -> 4) + (4 -> 5) = 9 + 7 = 16 : 갱신

- 4개의 간선으로 각 노드에 도달하는 방법 (위의 '3개 간선이용한 경우'에 더하여 구할 것)
  - 2번 노드 :
    - (1 -> 1) + (1 -> 2) = 0 + 5 = 5 : 갱신 x
    - (1 -> 4) + (4 -> 2) = 7 + 3 = 10 : 갱신 x
  - 3번 노드 :
    - (1 -> 1) + (1 -> 3) = 0 + 4 : 갱신 x
    - (1 -> 2) + (2 -> 3) = 5 + (-3) = 2 : 갱신 x
  - 4번 노드 :
    - (1 -> 3) + (3 -> 4) = 2 + 5 = 7 : 갱신 x
  - 5번 노드 :
    - (1 -> 2) + (2 -> 5) = 5 + 13 = 18 : 갱신 x
    - (1 -> 4) + (4 -> 5) = 7 + 7 = 14 : 갱신

<img src="https://user-images.githubusercontent.com/49135797/135316797-38e04aae-cf15-417f-8407-5c0e6037d920.png">

### 🤠 code

```c++
#include <stdio.h>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

int dist[101]; //구현 설명대로라면 이차원배열을 사용해야하지만, 1차원으로도 구현은 가능

struct Edge {
	int s;
	int e;
	int val;
	Edge(int a, int b, int c) {
		s = a;
		e = b;
		val = c;
	}
};

int main() {
	int i, j, n, m, a, b, c, s, e;
	vector<Edge> Ed;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++) {
		scanf("%d %d %d", &a, &b, &c);
		Ed.push_back(Edge(a, b, c));
	}
	for (i = 1; i <= n; i++) {
		dist[i] = 2147000000; //inf로 초기화
	}
	scanf("%d %d", &s, &e);
	dist[s] = 0;
	for (i = 1; i < n; i++) { //i는 특정 정점에 몇번만에 가는지 (1,2,3,4)
		for (j = 0; j < Ed.size(); j++) {
			int u = Ed[j].s;
			int v = Ed[j].e;
			int w = Ed[j].val;
			if (dist[u] != 2147000000 && dist[u] + w < dist[v]) { //기존값보다 작으면 갱신
				dist[v] = dist[u] + w;
			}
		}
	}

	//간선을 n개 택한경우
	for (j = 0; j < Ed.size(); j++) {
		int u = Ed[j].s;
		int v = Ed[j].e;
		int w = Ed[j].val;
		//간선을 n개 택하여 최소비용이 된 경우 -> 음의 사이클 존재
		if (dist[u] != 2147000000 && dist[u] + w < dist[v]) {
			printf("-1\n");
			exit(0);
		}
	}
	//음의 사이클 없다면 dist값 출력
	printf("%d\n", dist[e]);
	return 0;
}
```

### 📙 comment

다익스트라와 벨만포드의 차이점? <br>

그래프 알고리즘에서 '최소비용'을 구하는 대표적인 알고리즘으로 '다익스트라'와 '벨만포드', 그리고 '플로이드와샬' 알고리즘이 있다.<br>
<br>
앞에서 사용한 다익스트라와 벨만포드 알고리즘을 중심으로 비교해보자면,<br>
**다익스트라 알고리즘**은 "지금 당장 눈앞에 보이는, 연결된 정점들 중에서 최소비용인 정점"을 선택하는 그리디한 방식으로 접근했었다.<br>
<br>
**벨만포드 알고리즘**은 "모든 경우의 수"를 탐색해가면서 최소비용을 찾게된다. <br>
또한 이 문제에서 봤듯이, 음의 사이클이 존재하면 안된다.
