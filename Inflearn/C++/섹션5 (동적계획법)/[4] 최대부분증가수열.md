# 인프런 알고리즘 문제풀이(C/C++)

## 동적계획법 - [4]: 최대 부분 증가수열(LIS: Longest Increasing Subsequence)

### 🌴 문제

N개의 자연수로 이루어진 수열이 주어졌을 때, 그 중에서 가장 길게 증가하는(작은 수에서 큰 수로) 원소들의 집합을 찾는 프로그램을 작성하라. 예를 들어, 원소가 2, 7, 5, 8, 6, 4, 7, 12, 3 이면 가장 길게 증가하도록 원소들을 차례대로 뽑아내면 2, 5, 6, 7, 12를 뽑아내어 길이가 5인 최대 부분 증가수열을 만들 수 있다.

#### ◻ 입력

첫째 줄은 입력되는 데이터의 수 N(2≤N≤1,000, 자연수)를 의미하고, 둘째 줄은 N개의 입력데이터들이 주어진다.<br>
입력예시 : <br>
8<br>
5 3 7 8 6 2 9 4

#### ◻ 출력

첫 번째 줄에 부분증가수열의 최대 길이를 출력한다.<br>
출력예시 : 4

---

### 💡 구현 IDEA

위의 입력예시로,각 값이 마지막 항이 될때 증가수열이 될 수 있는 경우를 살펴보자

- 5가 마지막 항 : `5`
- 3이 마지막 항 : `3`
- 7이 마지막 항 : `5 7` / `3 7`
- 8이 마지막 항 : `5 8` / `3 8` / `5 7 8` / `3 7 8`
- 6이 마지막 항 : `5 6` / `3 6`
- 2가 마지막 항 : `2`
- 9가 마지막 항 : `5 9` / `3 9` / `5 7 9` / `3 7 9` / `5 8 9` / `3 8 9` / `5 7 8 9` / `3 7 8 9` / `5 6 9` / `3 6 9` / `2 9`
- 4가 마지막 항 : `3 4` / `2 4`

**`dy` 배열** : 해당 인덱스 값이 증가수열의 마지막 항일때 최대 길이가 담김 <br>
-> 해당 항 앞에 있는 더 작은 값들 중, 최대길이를 가진 배열값에 1을 더한다

- `dy[1]` : 1
- `dy[2]` : 1
- `dy[3]` : `dy[2]` + 1 = 2
- `dy[4]` : `dy[3]` + 1 = 3 <br>
  (5, 3, 7 모두 8보다 작고, 그 중 7이 마지막항일때의 길이가 최대이므로 `dy[3]`에 1을 더하여 최댓값을 구할 수 있다)
- `dy[5]` : `dy[2]` + 1 = 2 (6보다 작은 값은 5와 3이므로 `dy[1]`과 `dy[2]` 중 큰 값에 1을 더한다)
- `dy[6]` : 1 (2보다 작은 값은 없으므로)
- `dy[7]` : `dy[4]` + 1 = 3 + 1 = 4
- `dy[8]` : `dy[2]` + 1 = 2 (4보다 작은 값은 3와 2이므로 `dy[2]`와 `dy[6]` 중 큰 값에 1을 더한다)

최종적으로, 배열의 값 중 최댓값을 출력한다 <br>
(주의! 꼭 배열의 마지막 값을 출력해야하는 것이 아님)

### 🤠 code

```c++
#include <stdio.h>
#include <vector>
using namespace std;

int main() {
	int n, res = 0;
	scanf("%d", &n);
	vector<int> arr(n + 1), dy(n + 1);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &arr[i]);
	}
	dy[1] = 1;
	for (int i = 2; i <= n; i++) {
		int max = 0;
		for (int j = i - 1; j >= 1; j--) {
			if (arr[j] < arr[i] && dy[j] > max) {
				max = dy[j];
			}
		}
		dy[i] = max + 1;
		if (dy[i] > res) res = dy[i];
	}
	printf("%d\n", res);
	return 0;
}
```
