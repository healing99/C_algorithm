## 인프런 알고리즘 문제풀이(C/C++)

## 동적계획법 - [9]: 가방문제(냅색 알고리즘: Knapsack Algorithm)

#### ◻ 입력

첫 번째 줄은 보석 종류의 개수와 가방에 담을 수 있는 무게의 한계값이 주어진다. <br>
두 번째 줄부터 각 보석의 무게와 가치가 주어진다.<br>
가방의 저장무게는 1000kg을 넘지 않는다. 보석의 개수는 30개 이내이다.<br>
입력예시 : <br>
4 11 <br>
5 12<br>
3 8 <br>
6 14 <br>
4 8

#### ◻ 출력

가방에 담을 수 있는 보석의 최대가치 출력<br>
출력예시 : 28

---

### 💡 구현 IDEA

**dynamic programming 방식은, 가장 작은 과정부터 생각하면서 구현**

`dy[j]`: 가방에 j 무게까지 담을 수 있을 때, 담을 수 있는 보석의 최대가치<br>

`dy[j] = dy[j - w]+ v` : 무게가 w인 보석을 제외한 상태에서, 해당 보석을 담는 과정 (가치 v 추가)
<br>

- dy 배열의 모든 값 0으로 초기화

- 보석 w = 5, v = 12

  - j = 5<br>
    `dy[5]` = `dy[0]` + 12 = 12

  - j = 6<br>
    `dy[6]` = `dy[1]` + 12 = 12

  - j = 7<br>
    `dy[7]` = `dy[2]` + 12 = 12

  - j = 8<br>
    `dy[8]` = `dy[3]` + 12 = 12

  - j = 9<br>
    `dy[9]` = `dy[4]` + 12 = 12

  - j = 10<br>
    `dy[10]` = `dy[5]` + 12 = 24

  - j = 11<br>
    `dy[11]` = `dy[6]` + 12 = 24

- 보석 w = 3, v= 8

  - j = 3<br>
    `dy[3]` = `dy[0]` + 8 = 8

  - j = 4<br>
    `dy[4]` = `dy[1]` + 8 = 8

  - j = 5<br>
    `dy[5]` = `dy[2]` + 8 = 8 => 기존의 `dy[5]` = 12 보다 작으므로 값을 갱신하지 않는다

  - j = 6<br>
    `dy[6]` = `dy[3]` + 8 = 16 => 기존의 `dy[6]` = 12 보다 크므로 값을 갱신 => `dy[6]` = 16

  - j = 7<br>
    `dy[7]` = `dy[4]` + 8 = 16 => 기존의 `dy[7]` = 12 보다 크므로 값을 갱신 => `dy[7]` = 16

  - j = 8<br>
    `dy[8]` = `dy[5]` + 8 = 20 => 기존의 `dy[8]` = 12 보다 크므로 값을 갱신 => `dy[8]` = 20

  - j = 9<br>
    `dy[9]` = `dy[6]` + 8 = 24 => 기존의 `dy[9]` = 12 보다 크므로 값을 갱신 => `dy[9]` = 24

  - j = 10<br>
    `dy[10]` = `dy[7]` + 8 = 24 => 기존의 `dy[10]` = 24과 동일하므로 값을 갱신하지 않는다

  - j = 11<br>
    `dy[11]` = `dy[8]` + 8 = 28 => 기존의 `dy[11]` = 24 보다 크므로 값을 갱신 => `dy[11]` = 28

<br>

=> 각 보석들마다 과정을 반복하여 결론적으로 `dy[11]`의 값을 출력한다

### 🤠 code

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	int n, m, w, v;
	cin >> n >> m;
	vector<int> dy(m + 1, 0); //0으로 초기화
	for (int i = 0; i < n; i++) {
		cin >> w >> v;
		for (int j = w; j <= m; j++) {
			dy[j] = max(dy[j], dy[j - w] + v);
		}
	}
	cout << dy[m];
	return 0;
}
```
