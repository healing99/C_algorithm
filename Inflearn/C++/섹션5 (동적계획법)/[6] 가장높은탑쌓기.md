# 인프런 알고리즘 문제풀이(C/C++)

## 동적계획법 - [6]: 가장 높은 탑 쌓기 (LIS 응용)

### 🌴 문제

밑면이 정사각형인 직육면체 벽돌들을 사용하여 탑을 쌓고자 한다. 탑은 벽돌을 한 개씩 아래에서 위로 쌓으면서 만들어 간다. <br>
아래의 조건을 만족하면서 가장 높은 탑을 쌓을 수 있는 프로그램을 작성하시오.<br>

(조건1) 벽돌은 회전시킬 수 없다. 즉, 옆면을 밑면으로 사용할 수 없다.<br>
(조건2) 밑면의 넓이가 같은 벽돌은 없으며, 또한 무게가 같은 벽돌도 없다.<br>
(조건3) 벽돌들의 높이는 같을 수도 있다.<br>
(조건4) 탑을 쌓을 때 밑면이 좁은 벽돌 위에 밑면이 넓은 벽돌은 놓을 수 없다.<br>
(조건5) 무게가 무거운 벽돌을 무게가 가벼운 벽돌 위에 놓을 수 없다.

#### ◻ 입력

입력 파일의 첫째 줄에는 입력될 벽돌의 수가 주어진다. 입력으로 주어지는 벽돌의 수는 최대 100개이다.<br>
둘째 줄부터는 각 줄에 한 개의 벽돌에 관한 정보인 벽돌 밑면의 넓이, 벽돌의 높이 그리고 무게가 차례대로 양의 정수로 주어진다.<br>
각 벽돌은 입력되는 순서대로 1부터 연속적인 번호를 가진다.<br>
입력예시 : <br>
5<br>
25 3 4<br>
4 4 6<br>
9 2 3<br>
16 2 5<br>
1 5 2

#### ◻ 출력

첫 번째 줄에 가장 높이 쌓을 수 있는 탑의 높이를 출력한다.<br>
출력예시 : 10

---

### 💡 구현 IDEA

밑면의 넓이를 기준으로 내림차순 정렬<br>
||0 |1|2|3|4|
|--|--|--|--|--|--|
|밑면넓이(s)|25|16|9|4|1|
|높이(h)|3|2|2|4|5|
|무게(w)|4|5|3|6|2|

`dy`배열 : 해당 인덱스 블록을 맨 최상단에 놓았을 때의 최대 높이<br>
**문제의 Point.** 최상단에 있는 블록을 하나씩 선정하여, 자기 바로 아래 있는 블록들을 결정해나가는 과정임!!<br>

- `dy[0]` : 0번 블록(s=25)이 최상단에 있을 때 최대 높이 => `dy[0]` = 3
- `dy[1]` : 1번 블록(s=16)이 최상단에 있을 때 최대 높이 => `dy[1]` = 2
  - 앞의 블록들의 "무게"와 비교(0번 블록의 무게가 더 크므로 1번 블록만 쌓음)
- `dy[2]` : 2번 블록(s=9)이 최상단에 있을 때 최대 높이 => `dy[2]` = `dy[0]` + 2 = 5
  - 앞의 블록들 중, "무게"가 더 큰 블록들 중(0번, 1번), 최대 높이를 가진 블록 위에 쌓음
- `dy[3]` : 3번 블록(s=4)이 최상단에 있을 때 최대 높이 => `dy[3]` = 4
  - 앞의 블록들의 "무게"와 비교(0,1,2번 블록들의 무게가 모두 다 크므로 3번 블록만 쌓음)
- `dy[4]` : 4번 블록(s=1)이 최상단에 있을 때 최대 높이 => `dy[4]` = `dy[2]` + 5 = 10
  - 앞의 블록들 중, "무게"가 더 큰 블록들 중(0번, 1번, 2번, 3번), 최대 높이를 가진 블록 위에 쌓음

최종적으로, `dy`배열의 값 중 최댓값을 출력한다 <br>
(주의! 꼭 배열의 마지막 값을 출력해야하는 것이 아님)

### 🤠 code

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

struct Brick {
	int s, h, w;
	Brick(int a, int b, int c) {
		s = a, h = b, w = c;
	}
	bool operator<(const Brick& b) const { //s를 기준으로 내림차순 정렬
		return s > b.s; //앞 자료(호출한 객체)가 뒷 자료(매개변수로 넘어온 것)
	}
};
int main() {
	int n, a, b, c, max_h = 0, res = 0;
	scanf("%d", &n);
	vector<Brick> Bricks;
	vector<int> dy(n, 0);
	for (int i = 0; i < n; i++) {
		scanf("%d %d %d", &a, &b, &c);
		Bricks.push_back(Brick(a, b, c));
	}
	sort(Bricks.begin(), Bricks.end()); //내림차순 정렬됨
	dy[0] = Bricks[0].h;
	res = dy[0];
	for (int i = 1; i < n; i++) {
		max_h = 0;
		for (int j = i - 1; j >= 0; j--) {
			if (Bricks[j].w > Bricks[i].w && dy[j] > max_h) {
				max_h = dy[j];
			}
		}
		dy[i] = max_h + Bricks[i].h;
		res = max(res, dy[i]);
	}
	printf("%d\n", res);
}
```
