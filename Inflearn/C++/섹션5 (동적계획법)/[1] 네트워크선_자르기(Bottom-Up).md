# 인프런 알고리즘 문제풀이(C/C++)

## 동적계획법 - [1]: 네트워크 선 자르기(Bottom-Up)

### 🌴 문제

현수는 네트워크 선을 1m, 2m의 길이를 갖는 선으로 자르려고 합니다.
예를 들어 4m의 네트워크 선이 주어진다면<br>
1 ) 1m+1m+1m+1m<br>
2 ) 2m+1m+1m<br>
3 ) 1m+2m+1m<br>
4 ) 1m+1m+2m<br>
5 ) 2m+2m<br>
의 5가지 방법을 생각할 수 있습니다.<br>
(2)와 (3)과 (4)의 경우 왼쪽을 기준으로 자르는 위치가 다르면 다른 경우로 생각한다.<br>
그렇다면 네트워크 선의 길이가 Nm라면 몇 가지의 자르는 방법을 생각할 수 있나요?

#### ◻ 입력

첫째 줄은 네트워크 선의 총 길이인 자연수 N(3≤N≤45)이 주어집니다.<br>
입력예시: 7

#### ◻ 출력

첫 번째 줄에 부분증가수열의 최대 길이를 출력한다.<br>
출력예시: 21

---

### 💡 구현 IDEA

동적계획법 중 Bottom-Up : 작은 문제부터 차근차근 구해나가는 방식 사용

- `dy`라는 일차원 배열 만들고, 각 인덱스(1, 2, ..., 7) 마다 각각 자르는 방식의 수를 저장
- 길이 1짜리를 자르는 방식 **f(1)** : 1 (1가지)
- 길이 2짜리를 자르는 방식 **f(2)** : 1+1, 2 (2가지)
- 길이 3짜리를 자르는 방식 **f(3)** : 마지막 조각의 길이가 1이냐 2이냐의 두 경우에 따라 다르므로<br>
  앞에 남은 길이 2짜리랑 길이 1짜리를 자르는 방식을 더하면 된다 -> **f(1) + f(2)**
- 따라서 점화식을 구해보면 `f(n) = f(n-2) + f(n-1)`

### 🤠 code

```c++
#include <iostream>
using namespace std;

int dy[50];
int main() {
	int n;
	cin >> n;
	dy[1] = 1;
	dy[2] = 2;
	for (int i = 3; i <= n; i++) {
		dy[i] = dy[i - 2] + dy[i - 1];
	}
	cout << dy[n];
	return 0;
}
```

### 📙 comment

**동적계획법**<br>
Bottom-Up vs. Top-Down<br>
**Bottom-Up** : 작은 문제부터 차근차근 구해나가는 방식<br>
**Top-Down** : 재귀와 같은 방식으로 위에서 아래로 내려오는 방식, 함수 호출을 줄이기 위해 메모이제이션을 사용
