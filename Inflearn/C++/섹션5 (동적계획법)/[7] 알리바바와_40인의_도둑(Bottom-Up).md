# 인프런 알고리즘 문제풀이(C/C++)

## 동적계획법 - [7]: 알리바바와 40인의 도둑(Bottom-Up)

### 🌴 문제

알리바바는 40인의 도둑으로부터 금화를 훔쳐 도망치고 있습니다.
알리바바는 도망치는 길에 평소에 잘 가지 않던 계곡의 돌다리로 도망가고자 한다.
계곡의 돌다리는 N×N개의 돌들로 구성되어 있다. 각 돌다리들은 높이가 서로 다릅니다.
해당 돌다리를 건널때 돌의 높이 만큼 에너지가 소비됩니다. 이동은 최단거리 이동을 합니다.
즉 현재 지점에서 오른쪽 또는 아래쪽으로만 이동해야 합니다.
N\*N의 계곡의 돌다리 격자정보가 주어지면 (1, 1)격자에서 (N, N)까지 가는데 드는 에너지의
최소량을 구하는 프로그램을 작성하세요.
만약 N=3이고, 계곡의 돌다리 격자 정보가 다음과 같다면

<img src="https://user-images.githubusercontent.com/49135797/138600674-9ea82e23-49fd-4142-88d5-b65755fa1375.png" height= 160/>

(1, 1)좌표에서 (3, 3)좌표까지 가는데 드는 최소 에너지는 3+2+3+4+2=14이다.

#### ◻ 입력

첫 번째 줄에는 자연수 N(1<=N<=20)이 주어진다.<br>
두 번째 줄부터 계곡의 N\*N 격자의 돌다리 높이(10보다 작은 자연수) 정보가 주어진다.<br>
입력예시 : <br>
5<br>
3 7 2 1 9<br>
5 8 3 9 2<br>
5 3 1 2 3<br>
5 4 3 2 1<br>
1 7 5 2 4

#### ◻ 출력

첫 번째 줄에 (1, 1)출발지에서 (N, N)도착지로 가기 위한 최소 에너지를 출력한다.<br>
출력예시 : 25

---

### 💡 구현 IDEA

원래 배열 `arr`과 다이나믹 이차원 배열 `dy`<br>

`dy[i][j]` : (0, 0)에서 (i, j)까지의 최소 비용

0행에 있는 dy값들은 모두 왼쪽에서 오는 경우 밖에 없으니까 바로 초기화

- `dy[0][0]` = 3
- `dy[0][1]` = `dy[0][0]` + `arr[0][1]` = 3 + 3 = 6
- `dy[0][2]` = `dy[0][1]` + `arr[0][2]` = 6 + 5 = 11

0열에 있는 dy값들은 모두 위쪽에서 오는 경우 밖에 없으니까 바로 초기화

- `dy[1][0]` = `dy[0][0]` + `arr[1][0]` = 3 + 2 = 5
- `dy[2][0]` = `dy[1][0]` + `arr[2][0]` = 5 + 6 = 11

위에서 또는 왼쪽에서 오는 경우 중 경로의 합이 최소인 것을 저장

- `dy[1][1]` = 5 + 3 = 8<br>
  ( min(`dy[0][1]`, `dy[1][0]`) + `arr[1][1]` )
- `dy[1][2]` = 8 + 4 = 12<br>
  ( min(`dy[0][2]`, `dy[1][1]`) + `arr[1][2]` )
- `dy[2][1]` = 8 + 5 = 13<br>
  ( min(`dy[2][0]`, `dy[1][1]`) + `arr[2][1]` )
- `dy[2][2]` = 12 + 2 = 14<br>
  ( min(`dy[2][1]`, `dy[1][2]`) + `arr[2][2]` )

=> 최종적으로 `dy[2][2]`의 값 14를 출력

### 🤠 code

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int arr[21][21], dy[21][21];

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> arr[i][j];
		}
	}
	dy[0][0] = arr[0][0];

	for (int i = 1; i < n; i++) { // 가장자리 초기화
		dy[0][i] = dy[0][i - 1] + arr[0][i];
		dy[i][0] = dy[i - 1][0] + arr[i][0];
	}

	for (int i = 1; i < n; i++) {
		for (int j = 1; j < n; j++) {
			dy[i][j] = min(dy[i - 1][j], dy[i][j - 1]) + arr[i][j];
		}
	}
	cout << dy[n - 1][n - 1];
	return 0;
}
```
