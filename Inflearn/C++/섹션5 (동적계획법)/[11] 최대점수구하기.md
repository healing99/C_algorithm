## 인프런 알고리즘 문제풀이(C/C++)

## 동적계획법 - [11]: 최대점수 구하기 (냅색 알고리즘: Knapsack Algorithm)

제한시간 M안에 N개의 문제 중 최대점수를 얻을 수 있도록 구현
(단!! 한 유형당 한개만 풀 수 있다)

#### ◻ 입력

첫 번째 줄에 문제의 개수N(1<=N<=100)과 제한 시간 M(10<=M<=1000)이 주어진다.<br>
두 번째 줄부터 N줄에 걸쳐 문제를 풀었을 때의 점수와 푸는데 걸리는 시간이 주어진다.<br>
입력예시 : <br>
5 20<br>
10 5<br>
25 12<br>
15 8<br>
6 3<br>
7 4

#### ◻ 출력

첫 번째 줄에 제한 시간안에 얻을 수 있는 최대 점수를 출력<br>
출력예시 : 41

---

### 💡 구현 IDEA

9번, 10번 문제와의 차이점 : 한 유형당 한개만 풀 수 있음<br>

`dy[j]`: j 시간이 주어졌을때, 얻을 수 있는 최대 점수<br>
=> 0으로 초기화<br>

**ps**: 해당 문제의 점수, **pt** : 해당 문제의 시간<br>
`dy[j] = dy[j - pt] + ps` : 해당 문제를 담는 과정 (ps값 추가)<br>
=> 최댓값으로 갱신<br>
=> 주의: 뒤에서부터 앞으로 전진하면서 값 채워나가기 (그러면 특정 문제를 중복하지 않게됨!)<br>
<br>
**결론적으로 `dy[20]`의 값 출력**

### 🤠 code

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	int n, m, ps, pt;
	cin >> n >> m;
	vector<int> dy(m + 1, 0);
	for (int i = 0; i < n; i++) {
		cin >> ps >> pt;
		for (int j = m; j >= pt; j--) {
			dy[j] = max(dy[j], dy[j - pt] + ps);
		}
	}
	cout << dy[m];
	return 0;
}
```
