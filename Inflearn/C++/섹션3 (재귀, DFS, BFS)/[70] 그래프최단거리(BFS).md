# 인프런 알고리즘 문제풀이(C/C++)

## [70]: 그래프 최단거리 (BFS)

### 🌴 문제

다음 그래프에서 1번 정점에서 각 정점으로 가는 최소 이동 간선수를 출력하세요.

<img src="https://user-images.githubusercontent.com/49135797/120521331-ce528480-c40f-11eb-99a0-25e22c51f18c.PNG" width="380px"/>

#### ◻ 입력

첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연결정보가 주어진다.<br>
입력예시 : <br>
6 9<br>
1 3<br>
1 4<br>
2 1<br>
2 5<br>
3 4<br>
4 5<br>
4 6<br>
6 2<br>
6 5

#### ◻ 출력

1번 정점에서 각 정점으로 가는 최소 간선수를 2번 정점부터 차례대로 출력하세요.<br>
출력예시 :<br>
2 : 3<br>
3 : 1<br>
4 : 1<br>
5 : 2<br>
6 : 2<br>

---

### 💡 구현 IDEA

**큐**를 사용하여 **너비우선탐색**으로 구현한다 <br>

`dis` 배열 : 1부터 n정점까지 가는 최소 간선의 개수가 입력됨 <br>
`ch` 배열 : 방문 여부 체크하는 배열 <br><br>

[과정 설명]

- 출발정점 1을 Q에 넣기 <br>
- Q에서 1이 나옴 <br>
- 정점 1에서 한번만에 갈 수 있는 정점을 방문 (3번 정점) / Q에 3 넣기 <br>
- `dis[3]`의 값은 1이 됨 (`dis[1]`+1) : 1번 정점에서 3번 정점까지 가는 최소 간선 수가 1이라는 의미 <br>
- 정점 1에서 한번만에 갈 수 있는 정점을 방문 (4번 정점) / Q에 4 넣기 <br>
- `dis[4]`의 값은 1이 됨 (`dis[1]`+1) : 1번 정점에서 4번 정점까지 가는 최소 간선 수가 1이라는 의미 <br>
- Q에서 3이 나옴 <br>
- 정점 3에서 한번만에 갈 수 있는 정점을 방문 -> 없음 <br>
- Q에서 4가 나옴 <br>
- 정점 4에서 한번만에 갈 수 있는 정점을 방문 (5번 정점) / Q에 5 넣기 <br>
- `dis[5]`의 값은 2이 됨 (`dis[4]`+1) : 1번 정점에서 5번 정점까지 가는 최소 간선 수가 2라는 의미 (4번 정점을 통해서 갔기 때문) <br>
- 정점 4에서 한번만에 갈 수 있는 정점을 방문 (6번 정점) / Q에 6 넣기 <br>
- `dis[6]`의 값은 2이 됨 (`dis[4]`+1) : 1번 정점에서 6번 정점까지 가는 최소 간선 수가 2라는 의미 (4번 정점을 통해서 갔기 때문) <br>
- Q에서 5가 나옴 <br>
- 정점 5에서 한번만에 갈 수 있는 정점을 방문 -> 없음 <br>
- Q에서 6이 나옴 <br>
- 정점 6에서 한번만에 갈 수 있는 정점을 방문 (2번 정점) / Q에 2 넣기 <br>
- `dis[2]`의 값은 3이 됨 (`dis[6]`+1) : 1번 정점에서 2번 정점까지 가는 최소 간선 수가 2라는 의미 (6번 정점을 통해서 갔기 때문) <br>
- Q에서 2가 나옴 <br>
- 정점 2에서 한번만에 갈 수 있는 정점을 방문 -> 없음 <br>
- 큐는 이제 비워져서 종료 <br>
- 최종적으로 `dis`배열 값 출력 <br>

<img src="https://user-images.githubusercontent.com/49135797/120521211-a6fbb780-c40f-11eb-8e8c-c2ce5248c2de.png"/>

### 🤠 code

```c++
#include<stdio.h>
#include <queue>
using namespace std;

int ch[30], dis[30];
int main() {
	int i, n, m, a, b, x;
	vector<int> map[30];
	queue<int> Q;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++) {
		scanf("%d %d", &a, &b);
		map[a].push_back(b);
	}
	Q.push(1);
	ch[1] = 1;
	while (!Q.empty()) { //Q가 비워있지 않을때까지
		x = Q.front(); //Q의 맨 앞 요소 반환
		Q.pop(); //아예 꺼내기
		for (i = 0; i < map[x].size(); i++) { //연결된 노드 탐색
			if (ch[map[x][i]] == 0) {
				ch[map[x][i]] = 1;
				Q.push(map[x][i]);
				dis[map[x][i]] = dis[x] + 1; //dis[x]: 1번에서 x번 노드까지 최소간선수
			}
		}
	}
	for (i = 2; i <= n; i++) {
		printf("%d : %d\n", i, dis[i]);
	}
	return 0;
}
```

### 📙 comment

**큐(queue)** STL 사용하기 <br>

헤더파일 포함<br>
`#include <queue>`

큐 생성하기 <br>
`queue<int> Q;`

큐에 원소 삽입(뒤에) <br>
`Q.push(1);`

큐의 맨 앞 원소 아예 꺼내기(삭제)<br>
`Q.pop();`

큐의 맨 앞 원소 조회하여 반환 (아예 꺼내는건 아님)<br>
`x = Q.front();`

큐의 맨 뒤 원소 조회하여 반환 (아예 꺼내는건 아님)<br>
`x = Q.back();`

큐가 비어있으면 true, 아니면 false 반환<br>
`Q.empty()`

큐의 사이즈 반환<br>
`Q.size()`
