# 인프런 알고리즘 문제풀이(C/C++)

## [51]: 영지(territory) 선택 : (large) 
#### * 제한시간 : 1초/ 배열의 크기 : 700

### 🌴 문제

세종대왕은 현수에게 현수가 다스릴 수 있는 영지를 하사하기로 했다. 전체 땅은 사각형으로 표시된다. 그 사각형의 땅 중에서 세종대왕이 현수가 다스릴 수 있는 땅의 크기(세로의 길이와 가로의 길이)를 정해주면 전체 땅 중에서 그 크기의 땅의 위치를 현수가 정하면 되는 것이다.
전체 땅은 사각형의 모양의 격자로 되어 있으며, 그 사각형 땅 안에는 많은 오렌지 나무가 심겨져 있다.<br>
현수는 오렌지를 무척 좋아하여 오렌지 나무가 가장 많이 포함되는 지역을 선택하고 싶어 한다. 현수가 얻을 수 있는 영지의 오렌지 나무 최대 개수를 출력하는 프로그램을 작성하세요. <br>
다음과 같은 땅의 정보가 주어지고, 현수가 하사받을 크기가, 가로 2, 세로 3의 크기이면 가장 많은 오렌지 나무가 있는 영지는 총 오렌지 나무의 개수가 16인 3행 4열부터 시작하는 구역이다.<br>

<img src="https://user-images.githubusercontent.com/49135797/113561793-218e9d80-9640-11eb-916e-a2118bbf5c30.png" width="210px" height="210px"/>
<br>

#### ◻ 입력

첫 줄에 H(세로길이)와 W(가로길이)가 입력된다. (5<=H, W<=700) <br>
그 다음 H줄에 걸쳐 각 사각형 지역에 오렌지의 나무 개수(1 ~ 9개) 정보가 주어진다. <br>
그 다음 영지의 크기인 세로길이(1 ~ H)와 가로길이(1 ~ W)가 차례로 입력된다.

#### ◻ 출력

첫 줄에 현수가 얻을 수 있는 오렌지 나무의 최대 개수를 출력한다.

---

### 💡 구현 IDEA

- 배열의 크기가 커지고 제한시간이 생김에 따라 이중 for문을 사용하도록 구현<br>
- 값을 읽는 동시에 값을 누적하여 더하고 이를 dy배열에 저장 (직사각형 형태로)<br>
- 연산을 통해 구하고자 하는 영역의 합을 구하고, 비교하면서 최댓값을 얻음

### 💬 참고 code (제한시간 : 1초/ 배열의 크기 : 700)
```c++
#include <stdio.h>
#include <algorithm>
using namespace std;
int arr[701][701], dy[701][701];

int main(){
	int h, w, n, m, i, j, tmp, max=-2147000000;
	scanf("%d %d", &h, &w);
	for(i=1; i<=h; i++){
		for(j=1; j<=w; j++){
			scanf("%d", &arr[i][j]);
			dy[i][j]=dy[i-1][j]+dy[i][j-1]-dy[i-1][j-1]+arr[i][j]; //동적으로 합을 구하여 저장하는 배열	 
		}
	}
	scanf("%d %d", &n, &m);
	for(i=n; i<=h; i++){
		for(j=m; j<=w; j++){
			tmp=dy[i][j]-dy[i-n][j]-dy[i][j-m]+dy[i-n][j-m];
			if(tmp>max) max=tmp;
		}
	}
	printf("%d\n", max);
	return 0;
}
```